#!/usr/bin/env ruby
#
# Copyright (C) 2013 NEC Corporation
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License, version 2, as
# published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
#

required_path = File.dirname( __FILE__ ) + '/lib'
$LOAD_PATH.unshift required_path unless $LOAD_PATH.include? required_path

require 'optparse'
begin
require 'rubygems'
rescue LoadError
end
require 'json'
require 'sinatra/base'

require 'errors'
require 'configure'
require 'log'
require 'overlay_network'
require 'webrick_wrapper'

class RestApi < Sinatra::Base

  set :reflector_mode, false
  set :server, [ 'webrick_wrapper' ]

  logger = Log.instance
  use Rack::CommonLogger, logger

  def json_parse request, requires = []
    logger = Log.instance
    request.body.rewind
    body = request.body.read.gsub( /\000.*$/, '' ) # XXX
    parameters = JSON.parse( body, :symbolize_names => true )
    requires.each do | each |
      raise BadReuestError.new unless parameters.has_key? each
    end
    parameters
  end

  def json_generate response
    JSON.pretty_generate( response ) << "\n"
  end

  def no_message_body response
    ""
  end

  # Error

  #set :dump_errors, false
  set :show_exceptions, false

  error do
    e = env[ 'sinatra.error' ]
    content_type 'text/plain'
    status e.code if e.kind_of?( NetworkAgentError )
    e.message + "\n"
  end

  # Debug

  before do
    logger.debug "url='#{ request.path_info }'"
    request.body.rewind
    logger.debug "body='#{ request.body.read }'"
  end

  after do
    logger.debug "status=#{ status }"
    logger.debug "body='#{ body }'"
  end

  # Overlay Network

  get '/overlay_networks/?' do
    status 405
  end

  post '/overlay_networks/?' do
    if settings.reflector_mode 
      status 405
    else
      logger.debug "#{ __FILE__ }:#{ __LINE__ }: Create a new overlay network associated."
      requires = [ :vni, :broadcast ]
      parameters = json_parse( request, requires )
      content_type :json, :charset => 'utf-8'
      status 202
      body no_message_body OverlayNetwork.create( parameters )
    end
  end

  put '/overlay_networks/?' do
    status 405
  end

  delete '/overlay_networks/?' do
    status 405
  end

  #

  get '/overlay_networks/:vni/?' do | vni |
    status 405
  end

  post '/overlay_networks/:vni/?' do | vni |
    status 405
  end

  put '/networks/:vni/?' do | vni |
    status 405
  end

  delete '/overlay_networks/:vni/?' do | vni |
    if settings.reflector_mode 
      status 405
    else
      logger.debug "#{ __FILE__ }:#{ __LINE__ }: Remove the overlay network identified by net_id."
      parameters = { :vni => vni }
      content_type :json, :charset => 'utf-8'
      status 202
      body no_message_body OverlayNetwork.destroy( parameters )
    end
  end

  # Reflector

  get '/reflector/?' do
    status 405
  end

  post '/reflector/?' do
    status 405
  end

  put '/reflector/?' do
    status 405
  end

  delete '/reflector/?' do
    status 405
  end

  #

  get '/reflector/:vni/?' do | vni |
    status 405
  end

  post '/reflector/:vni/?' do | vni |
    if settings.reflector_mode 
      logger.debug "#{ __FILE__ }:#{ __LINE__ }: Create a tunnel endpoint on the vni in the request URI."
      requires = [ :vni, :ip ]
      parameters = json_parse( request, requires )
      content_type :json, :charset => 'utf-8'
      status 202
      body no_message_body Reflector.add_endpoint( parameters )
    else
      status 405
    end
  end

  put '/reflector/:vni/?' do | vni |
    status 405
  end

  delete '/reflector/:vni/?' do | vni |
    status 405
  end

  #

  get '/reflector/:vni/:tunnel_endpoint/?' do | vni, tunnel_endpoint |
    status 405
  end

  post '/reflector/:vni/:tunnel_endpoint/?' do | vni, tunnel_endpoint |
    status 405
  end

  put '/reflector/:vni/:tunnel_endpoint/?' do | vni, tunnel_endpoint |
    status 405
  end

  delete '/reflector/:vni/:tunnel_endpoint/?' do | vni, tunnel_endpoint |
    if settings.reflector_mode 
      logger.debug "#{ __FILE__ }:#{ __LINE__ }: Remove a tunnel endpoint from the vni."
      parameters = { :vni => vni, :ip => tunnel_endpoint }
      content_type :json, :charset => 'utf-8'
      status 202
      body no_message_body Reflector.delete_endpoint( parameters )
    else
      status 405
    end
  end

  #

  get '/*' do
    status 404
  end

  post '/*' do
    status 404
  end

  put '/*' do
    status 404
  end

  delete '/*' do
    status 404
  end

  config = Configure.instance
  option = OptionParser.new
  option.on( '--controller_uri=arg', "Controller uri (default '#{ config[ 'controller_uri' ] }')" ) do | arg |
    config[ 'controller_uri' ] = arg
  end
  option.on( '--uri=arg', "Uri (default '#{ config[ 'uri' ] }')" ) do | arg |
    config[ 'uri' ] = arg
  end
  option.on( '--tunnel_endpoint=arg', "Tunnel endpoint (default '#{ config[ 'tunnel_endpoint' ] }')" ) do | arg |
    config[ 'tunnel_endpoiunt' ] = arg
  end
  option.on( '--[no-]reflector-mode', "Enable reflector mode (default '#{ config[ 'reflector_mode' ] }')" ) do | arg |
    config[ 'reflector_mode' ] = arg
  end
  option.on( '--pid-file=arg', "Pid file (default '#{ config[ 'pid_file' ] }')" ) do | arg |
    config[ 'pid_file' ] = arg
  end
  option.on( '--log-file=arg', "Log file (default '#{ config[ 'log_file' ] }')" ) do | arg |
    config[ 'log_file' ] = arg
  end
  option.on( '-b', '--daemon', "Daemonize (default '#{ config[ 'daemon' ] }')" ) do | arg |
    config[ 'daemon' ] = arg
  end
  option.on( '--address=arg', "Listen address (default '#{ settings.bind }')" ) do | arg |
    config[ 'listen-address' ] = arg
  end
  option.on( '--port=arg', "Listen port number (default '#{ settings.port }')" ) do | arg |
    config[ 'listen-port' ] = arg
  end
  option.on( '-d', '--debug', "Debug mode" ) do | arg |
    Log.instance.level = Log::DEBUG
  end
  option.on( '--help', "Show this message" ) do | arg |
    puts option.help
    exit 0
  end
  begin
    option.parse! ARGV
  rescue OptionParser::ParseError => e
    puts e.message
    puts option.help
    exit 1
  end
  if ARGV.size != 0
    puts option.help
    exit 1
  end
  set :reflector_mode, config[ 'reflector_mode' ]
  config[ 'daemon' ] = false if Log.instance.level == Log::DEBUG
  logger.log_file = config[ 'log_file' ] unless config[ 'log_file' ].nil?
  set :port, config[ 'listen_port' ]
  set :bind, config[ 'listen_address' ]

  run!

end
